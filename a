#!/usr/bin/env python3

import os
import json
import base64
import hashlib
import hmac
from pathlib import Path
from datetime import datetime
from typing import List, Dict, Tuple, Optional


class SimpleDecryptor:

    
    FILE_START_MARKER = "<<<FILE_START>>>"
    FILE_END_MARKER = "<<<FILE_END>>>"
    METADATA_START = "<<<METADATA_START>>>"
    METADATA_END = "<<<METADATA_END>>>"
    ENCRYPTED_MARKER = "<<<ENCRYPTED_CONTENT>>>"
    
    def __init__(self, password: str):
        self.password = password
        
    def _derive_key(self, salt: bytes, iterations: int = 100000) -> bytes:
        password_bytes = self.password.encode('utf-8')
        key = hashlib.pbkdf2_hmac('sha256', password_bytes, salt, iterations)
        return key
    
    def _xor_encrypt_decrypt(self, data: bytes, key: bytes) -> bytes:
        key_len = len(key)
        return bytes([data[i] ^ key[i % key_len] for i in range(len(data))])
    
    def _decrypt_data(self, encrypted_str: str) -> Tuple[Optional[str], bool]:

        try:
            combined = base64.b64decode(encrypted_str.encode('ascii'))
            
            
            salt = combined[:16]
            mac = combined[16:48]
            encrypted = combined[48:]
            
            
            key = self._derive_key(salt)
            
            
            expected_mac = hmac.new(key, encrypted, hashlib.sha256).digest()
            if not hmac.compare_digest(mac, expected_mac):
                return None, False
            
            
            decrypted_bytes = self._xor_encrypt_decrypt(encrypted, key)
            decrypted_str = decrypted_bytes.decode('utf-8')
            
            return decrypted_str, True
            
        except Exception as e:
            print(f"Error: {e}")
            return None, False
    
    def _read_encrypted_file(self, file_path: Path) -> str:
        with open(file_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()
        
        
        encrypted_lines = []
        in_content = False
        
        for line in lines:
            line = line.rstrip('\n')
            if line == self.ENCRYPTED_MARKER:
                in_content = True
                continue
            if in_content and not line.startswith('#'):
                encrypted_lines.append(line)
        
        return ''.join(encrypted_lines)
    
    def _extract_metadata(self, content: str) -> Optional[Dict]:
        try:
            start_idx = content.find(self.METADATA_START)
            end_idx = content.find(self.METADATA_END)
            
            if start_idx == -1 or end_idx == -1:
                return None
            
            metadata_str = content[start_idx + len(self.METADATA_START):end_idx].strip()
            return json.loads(metadata_str)
            
        except Exception as e:
            print(f"‚ö†Ô∏è : {e}")
            return None
    
    def _check_expiration(self, metadata: Dict) -> bool:
        try:
            expire_str = metadata.get('expire_at')
            if not expire_str:
                return True
            
            expire_date = datetime.fromisoformat(expire_str)
            now = datetime.now()
            
            if now > expire_date:
                return False
            
            remaining = expire_date - now
            return True
            
        except Exception as e:
            return False
    
    def _parse_files(self, content: str) -> List[Tuple[str, str, str]]:

        files = []
        lines = content.split('\n')
        
        i = 0
        while i < len(lines):
            line = lines[i]
            
            if line == self.FILE_START_MARKER:
                
                i += 1
                path = None
                ext = None
                
                while i < len(lines) and lines[i] != "---CONTENT---":
                    if lines[i].startswith("PATH: "):
                        path = lines[i][6:]
                    elif lines[i].startswith("EXT: "):
                        ext = lines[i][5:]
                    i += 1
                
                
                i += 1  
                content_lines = []
                
                while i < len(lines) and lines[i] != self.FILE_END_MARKER:
                    content_lines.append(lines[i])
                    i += 1
                
                if path and ext:
                    file_content = '\n'.join(content_lines)
                    files.append((path, ext, file_content))

            i += 1
        
        return files
    
    def _restore_files(self, files: List[Tuple[str, str, str]], output_dir: Path, root_name: str):
        
        root_dir = output_dir / root_name
        root_dir.mkdir(parents=True, exist_ok=True)
        
        print(f"\nüìÅ : {root_dir}")
        
        for relative_path, ext, content in files:
            file_path = root_dir / relative_path
            
            
            file_path.parent.mkdir(parents=True, exist_ok=True)
            
            
            try:
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                print(f"‚úì : {relative_path}")
            except Exception as e:
                print(f"‚ö†Ô∏è  : {relative_path} - {e}")
    
    def decrypt_and_unpack(self, encrypted_dir: str, output_dir: str) -> bool:

        encrypted_path = Path(encrypted_dir).resolve()
        output_path = Path(output_dir).resolve()
        
        if not encrypted_path.exists():
            raise FileNotFoundError(f": {encrypted_dir}")
        
        encrypted_files = sorted(encrypted_path.glob("med_*.txt"))
        
        if not encrypted_files:
            print("‚ùå ")
            return False
        
        print(f"\nüìÑ  {len(encrypted_files)} ")
        
        all_content = []
        
        for idx, file_path in enumerate(encrypted_files, 1):
            print(f"\nüîì  {idx}/{len(encrypted_files)}: {file_path.name}")
            
            encrypted_content = self._read_encrypted_file(file_path)
            
            decrypted_content, is_valid = self._decrypt_data(encrypted_content)
            
            if not is_valid or decrypted_content is None:
                print(f"‚ùå ")
                return False
            
            all_content.append(decrypted_content)
            print(f"‚úì ")
        
        
        full_content = '\n'.join(all_content)
        
        
        print("\nüìã ")
        metadata = self._extract_metadata(full_content)
        
        if not metadata:
            print("‚ùå ")
            return False
        
        print(f"‚úì : {metadata.get('root_name')}")
        print(f"‚úì : {metadata.get('file_count')}")
        print(f"‚úì : {metadata.get('created_at')}")
        
        
        if not self._check_expiration(metadata):
            return False
        
        
        print("\nüì¶ ...")
        files = self._parse_files(full_content)
        
        if not files:
            print("‚ùå ")
            return False
        
        print(f"‚úì : {len(files)} ")
        
        
        print("\nüíæ ...")
        self._restore_files(files, output_path, metadata.get('root_name', 'restored'))
        
        print(f"\n‚úÖ !")
        print(f"üìÅ : {output_path / metadata.get('root_name', 'restored')}")
        print(f"üìä : {len(files)} ")
        
        return True


def main():
    import sys
    
    print("=" * 80)
    print("üîì med v1.0")
    print("=" * 80)
    
    if len(sys.argv) > 1:
        encrypted_dir = sys.argv[1]
        output_dir = sys.argv[2] if len(sys.argv) > 2 else "./decrypted_output"
    else:
        encrypted_dir = input("\ninput dir: ").strip()
        output_dir = input("output dir: ").strip()
        if not output_dir:
            output_dir = "./decrypted_output"
    
    password = input("k: ").strip()
    if not password:
        print("‚ùå !")
        return
    
    try:
        decryptor = SimpleDecryptor(password)
        success = decryptor.decrypt_and_unpack(encrypted_dir, output_dir)
        
        if success:
            print("\n" + "=" * 80)
            print("üéâ !")
            print("=" * 80)
        else:
            print("\n" + "=" * 80)
            print("‚ùå ")
            print("=" * 80)
        
    except Exception as e:
        print(f"\n‚ùå : {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    main()
